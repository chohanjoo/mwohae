<?xml version="1.0" encoding="UTF-8"?>
<b:beans xmlns="http://www.springframework.org/schema/security"
         xmlns:b="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                        http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd">

    <!-- use-expressions 를 true로 두면 intercept-url의 access를 EL 문법으로 대체한다. -->
    <http auto-config="true" use-expressions="true">
        <intercept-url pattern="/login" access="permitAll" />

        <!-- username,password의 값은 페이지의 input name과 같다. -->
        <!-- processing-url은 로그인 폼이 보낼 위치와 같다.(action) -->
        <!-- authentication-failure-url은 로그인 처리 실패시 보내지는 곳이다. -->
        <form-login
                login-page="/login" password-parameter="pw"
                username-parameter="id" always-use-default-target="true"
                login-processing-url="/login/submit" authentication-failure-url="/login?error"
                default-target-url="/index" />

        <logout
                invalidate-session="true"
                logout-url="/logout"
                logout-success-url="/index"
        />

        <!-- Spring Security는 기본적으로 csrf 방지대책이 있고, form마다 토큰값을 추가해야한다. -->
        <!-- 예제에서는 disabled 하였다 -->
        <csrf disabled="true"/>
    </http>

    <!-- 인증처리를 어디에서 할 것인지에 대한 부분. 직접 만든 userService가 핸들링한다. -->
    <!-- annotation-driven 인 경우, 따로 bean 선언이 없는한 첫자리가 lower case인 id가 자동 생성됨 -->
    <authentication-manager>
        <authentication-provider user-service-ref="userSecurityService">
            <!-- mysql의 password() 함수로 암호화하여 저장한 경우 이를 비교하기 위한 클래스 -->
            <password-encoder ref="passwordEncoder"></password-encoder>
        </authentication-provider>
    </authentication-manager>

    <b:bean id="passwordEncoder" class="sns.message.util.MySqlPasswordEncoder" />
</b:beans>
